local LuaLogger = require("scripts.utils.logging").LuaLogger
local create_ts_class_instance = require("lualib_bundle").__TS__New
local log = create_ts_class_instance(LuaLogger, "stalker_generic");

----------------------------------------------------------------------------------------------------------------------
-- STALKER NPC INFO
----------------------------------------------------------------------------------------------------------------------
function set_npc_info(npc, ini, scheme, section)
  --printf("INFO SECTION [%s]", utils.to_str(section))

  local in_info	= get_infos_from_data(npc, utils.cfg_get_string(ini, section, "in", npc, false, ""))
  local out_info	= get_infos_from_data(npc, utils.cfg_get_string(ini, section, "out", npc, false, ""))

  for k,v in pairs(in_info) do
    npc:give_info_portion(v)
  end
  for k,v in pairs(out_info) do
    npc:disable_info_portion(v)
  end
end

function get_infos_from_data(npc, s)
  --	printf("get_infos_from_data [%s]", utils.to_str(s))
  local t = {}
  if s then
    for name in string.gfind( s, "(%|*[^%|]+%|*)%p*" ) do
      --			printf("[%s]", utils.to_str(name))
      local condlist = xr_logic.parse_condlist(npc, "in", name, name)
      if condlist then
        table.insert(t, xr_logic.pick_section_from_condlist(db.actor, npc, condlist))
      end
    end
  end
  return t
end


----------------------------------------------------------------------------------------------------------------------
-- STALKER IGNORE MONSTER THRESHOLD
----------------------------------------------------------------------------------------------------------------------
-- ���������� �� ������������ �� ����� ������. ���������� ����������� �������� �� ������� ������.
function reset_threshold(npc, scheme, st, section)
  local threshold_section
  if scheme == nil or scheme == "nil" then
    threshold_section = utils.cfg_get_string(st.ini, st.section_logic, "threshold", npc, false, "")
  else
    threshold_section = utils.cfg_get_string(st.ini, section, "threshold", npc, false, "")
  end

  --'printf("THRESHOLD SECTION [%s]", utils.to_str(threshold_section))
  if threshold_section then
    local max_ignore_distance	= utils.cfg_get_number(st.ini, threshold_section, "max_ignore_distance", npc, false)
    if max_ignore_distance then
      npc:max_ignore_monster_distance(max_ignore_distance)
    else
      npc:restore_max_ignore_monster_distance()
    end
    local ignore_monster		= utils.cfg_get_number(st.ini, threshold_section, "ignore_monster", npc, false)
    if ignore_monster then
      npc:ignore_monster_threshold(ignore_monster)
    else
      npc:restore_ignore_monster_threshold()
    end
  end
end

--'--------------------------------------------------------------------------------------------------------------------
--' INVULNERABILITY
--'--------------------------------------------------------------------------------------------------------------------

function is_need_invulnerability(npc)
  local npc_st = db.storage[npc:id()]
  local invulnerability = utils.cfg_get_string(npc_st.ini, npc_st.active_section, "invulnerable", npc, false, "", nil)

  if invulnerability == nil then
    return false
  end

  invulnerability = xr_logic.parse_condlist(npc, "invulnerability", "invulnerability", invulnerability)

  return xr_logic.pick_section_from_condlist(db.actor, npc, invulnerability) == "true"
end

--' ���������� �� ������������ �� ����� ������. ���������� ����������� �������� �� ������� ������.
function reset_invulnerability(npc, ini, section)
  local invulnerability = is_need_invulnerability(npc)

  printf("RESET INVULNERABILITY. npc[%s] = [%s]", npc:name(), tostring(invulnerability))
  if npc:invulnerable() ~= invulnerability then
    npc:invulnerable(invulnerability)
  end
end

function disable_invulnerability(npc)
  printf("DISABLE INVULNERABILITY. npc[%s] = [false]", npc:name())
  npc:invulnerable(false)
end

function update_invulnerability(npc)
  local invulnerability = is_need_invulnerability(npc)

  if npc:invulnerable() ~= invulnerability then
    printf("UPDATE INVULNERABILITY. npc[%s] = [%s]", npc:name(), tostring(invulnerability))
    npc:invulnerable(invulnerability)
  end
end

--'--------------------------------------------------------------------------------------------------------------------
--' TEAM SQUAD GROUP
--'--------------------------------------------------------------------------------------------------------------------
--' ���������� �� ������������ �� ����� ������. ���������� ����������� �������� �� ������� ������.
function reset_group(npc, ini, section)
  local group = utils.cfg_get_number(ini, section, "group", npc, false, -1)

  if group ~= -1 then
    npc:change_team(npc:team(), npc:squad(), group)
  end
end

function take_items_enabled(npc, scheme, st, section)
  local take_items = nil
  if(st.ini:line_exist(section, "take_items")) then
    take_items = utils.cfg_get_bool(st.ini, section, "take_items", npc, false, true)
  else
    take_items = utils.cfg_get_bool(st.ini, st.section_logic, "take_items", npc, false, true)
  end
  npc:take_items_enabled(take_items)
end

function can_select_weapon(npc, scheme, st, section)
  local str = utils.cfg_get_string(st.ini, section, "can_select_weapon", npc, false, "", "")
  if(str=="") then
    str = utils.cfg_get_string(st.ini, st.section_logic, "can_select_weapon", npc, false, "", "true")
  end

  local cond = xr_logic.parse_condlist(npc, section, "can_select_weapon", str)
  local can = xr_logic.pick_section_from_condlist(db.actor, npc, cond)
  npc:can_select_weapon(can=="true")
end
